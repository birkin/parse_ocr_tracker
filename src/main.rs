mod logger; // enables the log_debug!() and log_info!() macros

use clap::{arg, Command};
use serde::{Deserialize, Serialize};
use serde_json::Result as JsonResult;
// use std::io::{Seek, SeekFrom};
use std::{
    fs::File,
    io::{self, Read},
    path::{Path, PathBuf},
};
use walkdir::WalkDir;

/*
    Includes the file generated by the build.rs script, which looks like:
    pub const GIT_COMMIT: &str = "c5f7034f79bc3d49c1a9fb81c7cac6a8a778c5c3";
*/
include!(concat!(env!("OUT_DIR"), "/git_commit.rs")); // OUT_DIR is set by cargo; is the target dir; and is only available during build process

/*  
    Finds all files in the given directory that end with "ocr_complete.json" or "ingest_complete.json".
*/
fn find_json_files<P: AsRef<Path>>(path: P) -> (Vec<PathBuf>, Vec<PathBuf>) {
    let mut ocr_complete_paths = Vec::new();
    let mut ingest_complete_paths = Vec::new();

    for entry in WalkDir::new(path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().is_file())
    {
        let path = entry.into_path();
        if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
            if file_name.ends_with("ocr_complete.json") {
                ocr_complete_paths.push(path);
            } else if file_name.ends_with("ingest_complete.json") {
                ingest_complete_paths.push(path);
            } else {
                // log_debug!("zIgnoring file: {}", file_name);
                log_debug!("vIgnoring file: {}", file_name);
            }
        }
    }

    ocr_complete_paths.sort_by(|a, b| a.as_path().cmp(b.as_path()));
    ingest_complete_paths.sort_by(|a, b| a.as_path().cmp(b.as_path()));

    log_debug!("len-ocr_complete_paths: {}", ocr_complete_paths.len());
    log_debug!("len-ingest_complete_paths: {}", ingest_complete_paths.len());

    (ocr_complete_paths, ingest_complete_paths)
}

/*
    Represents the structure of the JSON files that are being parsed.
    Note that the `pid` and `pid_url` fields are not part of the original JSON files; they're populated later.
*/
#[derive(Debug, Deserialize, Serialize)]
struct Record {
    orientation: i32,
    orientation_conf: f64,
    script: String,
    script_conf: f64,
    image_name: String,
    word_count: i32,
    avg_confidence: f64,
    below_90: f64,
    below_60: f64,
    below_30: f64,
    pid: Option<String>,
    pid_url: Option<String>,
}

/* 
    Processes the JSON files, creating a data-vector.
*/
fn process_files(file_paths: Vec<PathBuf>, output_dir: &str) -> io::Result<()> {
    let mut data_vector: Vec<Record> = Vec::new();

    for path_buf in file_paths {
        let path = path_buf.as_path();
        let mut file = File::open(&path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        let record: JsonResult<Record> = serde_json::from_str(&contents);
        match record {
            Ok(rec) => {
                data_vector.push(rec);
            }
            Err(e) => log_debug!("Error parsing JSON from {:?}: {}", path, e),
        }
    }

    // After all files have been processed, check if there's any data to append
    if !data_vector.is_empty() {
        log_debug!("saving to CSV");
        save_to_csv(&data_vector, output_dir)?;
    }

    Ok(())
}

/*
    Saves the data-vector to a CSV file.
*/
fn save_to_csv(data: &[Record], output_dir: &str) -> io::Result<()> {
    let file_path = format!("{}/output.csv", output_dir); // Consider more sophisticated file naming
    let file = File::create(file_path)?;
    let mut wtr = csv::Writer::from_writer(file);

    for record in data {
        wtr.serialize(record)?;
    }
    wtr.flush()?;
    Ok(())
}

/*
    Main function.
*/
fn main() {
    // init logger --------------------------------------------------
    logger::init_logger().unwrap();

    // get args -----------------------------------------------------
    let matches = Command::new("parse_ocr_tracker")
        // .version("1.0z")
        .version(GIT_COMMIT)
        .about("Walks source_dir_path and lists all json files.")
        .arg(arg!(-s --source_dir_path <VALUE>).required(true))
        .arg(arg!(-o --output_dir_path <VALUE>).required(true))
        .get_matches();

    // get source_dir -----------------------------------------------
    let source_dir_temp_ref: &String = matches
        .get_one::<String>("source_dir_path")
        .expect("Failed to get required 'source_dir_path' argument.");
    let source_dir: &str = source_dir_temp_ref.as_str(); // or... let source_dir: String = source_dir_temp_ref.to_string();
                                                         // log_debug!("source-arg: {:?}", source_dir);
    log_info!("source-arg: {:?}", source_dir);

    // get output_dir -----------------------------------------------
    let output_dir_temp_ref: &String = matches
        .get_one::<String>("output_dir_path")
        .expect("Failed to get required 'output_dir_path' argument.");
    let output_dir: &str = output_dir_temp_ref.as_str();
    log_debug!("output-arg: {:?}", output_dir);

    // get paths ----------------------------------------------------
    // let paths_vector: Vec<PathBuf> = find_json_files(source_dir);
    let (ocr_paths, ingest_paths): (Vec<PathBuf>, Vec<PathBuf>) = find_json_files(source_dir);
    log_debug!("ocr_paths.len(): {}", ocr_paths.len());
    log_debug!("ingest_paths.len(): {}", ingest_paths.len());
    for path in &ocr_paths {
        // pretty-print each path
        log_debug!("{}", path.display());
    }

    // make a map of id-to-pid --------------------------------------

    // process files ------------------------------------------------
    if let Err(e) = process_files(ocr_paths, &output_dir) {
        log_debug!("Error processing files: {}", e);
    }
}

// let zz: () = the_var;
